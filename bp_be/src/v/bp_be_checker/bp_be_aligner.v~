module aligner 
 import bp_common_pkg::*;
 import bp_be_rv64_pkg::*;
 import bp_be_pkg::*;
 #(parameter vaddr_width_p                 = "inv"
   , parameter paddr_width_p               = "inv"
   , parameter branch_metadata_fwd_width_p = "inv"
   , parameter asid_width_p                = "inv"
   , localparam fe_fetch_width_lp  = `bp_fe_fetch_width(vaddr_width_p, branch_metadata_fwd_width_p)
  ) 
 (input clk_i
  , input reset_i
  , input  [fe_fetch_width_lp-1:0] input_fe_fetch_i
  , output logic [fe_fetch_width_lp-1:0] fe_fetch_o
  , input fe_queue_v_i
  , output logic fe_queue_v_o
  , output logic aligner_ready_o
  );

//bp_fe_fetch_s
//logic [bp_eaddr_width_gp-1:0]             pc;
//logic [bp_instr_width_gp-1:0]             instr;
//logic [branch_metadata_fwd_width_mp-1:0]  branch_metadata_fwd; 

//which instruction info is this in the case of having two compressed instructions in the fetch 32-bit instruction==> these are useful for branch instructions ==> is soft realignment in the FE checking this stuff ==> they had some aligments when there were two back to back branch instructions
//bp_fe_branch_metadata_fwd_s
//btb_tag
//btb_indx
//bht_indx
//ras_addr

// Declare parameterizable structures
`declare_bp_common_fe_be_if_structs(vaddr_width_p
                                    , paddr_width_p
                                    , asid_width_p
                                    , branch_metadata_fwd_width_p
                                   );

   
bp_fe_fetch_s fe_fetch, fe_fetch_out;   
assign fe_fetch   = input_fe_fetch_i;
assign fe_fetch_o = fe_fetch_out;
   
// ----------
// Registers
// ----------
// the last instruction was unaligned
logic unaligned_n, unaligned_q;
// save the unaligned part of the instruction to this ff
logic [15:0] unaligned_instr_n, unaligned_instr_q;
// the previous instruction was compressed
logic compressed_n, compressed_q;
// register to save the unaligned address
logic [63:0] unaligned_address_n, unaligned_address_q;
// get the next instruction, needed on a unaligned access
logic jump_unaligned_half_word;


// check if the lower compressed instruction was no branch otherwise we will need to squash this instruction
// but only if we predicted it to be taken, the predict was on the lower 16 bit compressed instruction
logic kill_upper_16_bit;
assign kill_upper_16_bit = fe_fetch.valid_branch_taken;//[0];

// ----------
// Registers
// ----------
always_comb begin : realign_instr
   unaligned_n          = unaligned_q;
   unaligned_instr_n    = unaligned_instr_q;
   compressed_n         = compressed_q;
   unaligned_address_n  = unaligned_address_q;
          
   // directly output this instruction. adoptions are made throughout the always comb block
   fe_fetch_out.pc                  = fe_fetch.pc;
   fe_fetch_out.instr               = fe_fetch.instr;
   fe_fetch_out.branch_metadata_fwd = fe_fetch.branch_metadata_fwd;
   fe_fetch_out.valid_branch_taken  = fe_fetch.valid_branch_taken;
   fe_fetch_out.iscompressed        = 0;
   //aligner_v_o is used to advance the queue/ not advancing the queue in the case of one more cycle need 
   aligner_ready_o                  = fe_queue_v_i;
   fe_queue_v_o                     = fe_queue_v_i;
   // we just jumped to a half word and encountered an unaligned 32-bit instruction
   jump_unaligned_half_word = 1'b0;

   // ---------------------------------
   // Input port & Instruction Aligner
   // ---------------------------------
   // check if the entry if the fetch FIFO is valid and if we are currently not serving the second part
   // of a compressed instruction
   if (fe_queue_v_i && !compressed_q) begin
      // ------------------------
      // Access on Word Boundary
      // ------------------------
      if (fe_fetch.pc[1] == 1'b0) begin
         // do we actually want the first instruction or was the address a half word access?
         if (!unaligned_q) begin
            // we got a valid instruction so we can satisfy the unaligned instruction
            unaligned_n = 1'b0;
            // check if the instruction is compressed
            if (fe_fetch.instr[1:0] != 2'b11) begin
               // it is compressed
               fe_fetch_out.instr = {15'b0, fe_fetch.instr[15:0]};
               fe_fetch_out.iscompressed = 1'b1;
               // we need to kill the lower prediction
               if (!fe_fetch.valid_branch_taken/*[0]*/)
                 fe_fetch_out.valid_branch_taken = 1'b0;

               // should we even look at the upper instruction bits?
               if (!kill_upper_16_bit) begin
                  // Yes, so...
                  // 1. Is the second instruction also compressed, like:
                  // _____________________________________________
                  // | compressed 2 [31:16] | compressed 1[15:0] |
                  // |____________________________________________
                  if (fe_fetch.instr[17:16] != 2'b11) begin
                     // yes, this was a compressed instruction
                     compressed_n = 1'b1;
                     // do not advance the queue pointer
                     aligner_ready_o = 1'b0;
                     // 2. or is it an unaligned 32 bit instruction like
                     // ____________________________________________________
                     // |instr [15:0] | instr [31:16] | compressed 1[15:0] |
                     // |____________________________________________________
                  end else begin
                     // save the lower 16 bit
                     unaligned_instr_n = fe_fetch.instr[31:16];
                     // save the address
                     unaligned_address_n = {fe_fetch.pc[63:2], 2'b10};
                     // and that it was unaligned
                     unaligned_n = 1'b1;
                     // this does not consume space in the FIFO
                  end
               end
            end
         end//!unaligned_q       

         // this is a full 32 bit instruction like
         // _______________________
         // | instruction [31:0]  |
         // |______________________
         // we have an outstanding unaligned instruction
         else if (unaligned_q) begin
            fe_fetch_out.pc = unaligned_address_q;
            fe_fetch_out.instr = {fe_fetch.instr[15:0], unaligned_instr_q};
            fe_fetch_out.iscompressed = 1'b0;
            // again should we look at the upper bits?
            if (!kill_upper_16_bit) begin
               // whats up with the other upper 16 bit of this instruction
               // is the second instruction also compressed, like:
               // _____________________________________________
               // | compressed 2 [31:16] | unaligned[31:16]    |
               // |____________________________________________
               if (fe_fetch.instr[17:16] != 2'b11) begin
                  // this was a compressed instruction
                  compressed_n  = 1'b1;
                  // do not advance the queue pointer
                  aligner_ready_o = 1'b0;
                  // unaligned access served
                  unaligned_n = 1'b0;
                  // we need to kill the lower prediction
                  if (!fe_fetch.valid_branch_taken/*[0]*/)
                    fe_fetch_out.valid_branch_taken = 1'b0;
                  
               // or is it an unaligned 32 bit instruction like
               // ____________________________________________________
               // |instr [15:0] | instr [31:16] | compressed 1[15:0] |
               // |____________________________________________________
               end else if (!kill_upper_16_bit) begin // if (fetch_entry_i.instruction[17:16] != 2'b11)
                  // save the lower 16 bit
                  unaligned_instr_n = fe_fetch.instr[31:16];
                  // save the address
                  unaligned_address_n = {fe_fetch.pc[63:2], 2'b10};
                  // and that it was unaligned
                  unaligned_n = 1'b1;
               end // if (!kill_upper_16_bit)
            end // if (!kill_upper_16_bit)
            // we've got a predicted taken branch we need to clear the unaligned flag if it was decoded as a lower 16 instruction
            else if (fe_fetch.valid_branch_taken) begin
               // the next fetch will start from a 4 byte boundary again
               unaligned_n = 1'b0;
            end
         end   
      end // if (fe_fetch.pc[1] == 1'b0)
      // ----------------------------
      // Access on half-Word Boundary
      // ----------------------------
      else if (fe_fetch.pc[1] == 1'b1) begin // address was a half word access
         // reset the unaligned flag as this is a completely new fetch (because consecutive fetches only happen on a word basis)
         unaligned_n = 1'b0;
         // this is a compressed instruction
         if (fe_fetch.instr[17:16] != 2'b11) begin
            // it is compressed
            fe_fetch_out.instr= {15'b0, fe_fetch.instr[31:16]};
            fe_fetch_out.iscompressed = 1'b1;
         // this is the first part of a 32 bit unaligned instruction
         end else begin
            // save the lower 16 bit
            unaligned_instr_n = fe_fetch.instr[31:16];
            // and that it was unaligned
            unaligned_n = 1'b1;
            // save the address
            unaligned_address_n = {fe_fetch.pc[63:2], 2'b10};
            // we need to wait for the second instruction
            aligner_ready_o = 1'b1;
            fe_queue_v_o = 1'b0;
            // we got to an unaligned instruction -> get the next entry to full-fill the need
            jump_unaligned_half_word = 1'b1;
         end // else: !if(fe_fetch.instr[17:16] != 2'b11)
         // there can never be a whole 32 bit instruction on a half word access
      end // if (fe_fetch.pc[1] == 1'b1)
   end // if (fe_queue_v_i && !compressed_q)
   
   // ----------------------------
   // Next compressed instruction
   // ----------------------------
   // we are serving the second part of an instruction which was also compressed
   if (compressed_q) begin
      aligner_ready_o = fe_queue_v_i;
      compressed_n  = 1'b0;
      fe_fetch_out.instr = {16'b0, fe_fetch.instr[31:16]};
      fe_fetch_out.iscompressed = 1'b1;
      fe_fetch_out.pc = {fe_fetch.pc[63:2], 2'b10};
      fe_queue_v_o = 1'b1;
   end // if (compressed_q)
   
   // if we didn't get an acknowledge keep the registers stable
   if (!fe_queue_v_i && !jump_unaligned_half_word) begin
      unaligned_n         = unaligned_q;
      unaligned_instr_n   = unaligned_instr_q;
      compressed_n        = compressed_q;
      unaligned_address_n = unaligned_address_q;
   end

end // block: realign_instr
   
   
// assign the correct address for a potentially faulting unaligned instruction
           // we've already done the re-alignment for the instruction word so we
           // can just assign it here to tval
//   fetch_entry_o.ex.tval = fetch_entry_o.address;
// this above line is waht I talked to Ajay about, that we need to send the compresed/not compressed to the ex_stage
// because it needs to know the correct expected npc ==> here they are passing the correct address itself instead of the comp/not comp           


// ---------
// Registers
// ---------
always_ff @(posedge clk_i) begin
   if (reset_i || ~fe_queue_v_i) begin
      unaligned_q         <= 1'b0;
      unaligned_instr_q   <= 16'b0;
      unaligned_address_q <= 64'b0;
      compressed_q        <= 1'b0;
   end else begin
      unaligned_q         <= unaligned_n;
      unaligned_instr_q   <= unaligned_instr_n;
      unaligned_address_q <= unaligned_address_n;
      compressed_q        <= compressed_n;
   end
end    
    
endmodule : aligner